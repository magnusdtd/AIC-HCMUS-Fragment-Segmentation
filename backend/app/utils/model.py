import os, base64
from ultralytics import YOLO
from huggingface_hub import hf_hub_download
import numpy as np
import cv2
from PIL import Image
from random import randint
from io import BytesIO
import matplotlib.pyplot as plt

class Model:
    def __init__(
        self,
        repo_id: str = "magnusdtd/aic-hcmus-2025-yolo11m-seg",
        model_filename: str = "yolov11m_finetuned.pt",
    ):
        # Download the model file from Hugging Face Hub
        self.yolo_path = hf_hub_download(
            repo_id=repo_id,
            filename=model_filename,
            cache_dir=os.path.expanduser("~/.cache/huggingface/yolo"),
            force_filename=model_filename
        )

        # Load the YOLO model
        self.model = YOLO(self.yolo_path)
        self.model.info()
        self.model.to("cpu")

    def preprocess(self, img):
        pass

    def postprocess(self, model_result):
        pass

    @staticmethod
    def get_overlaid_mask(image: Image, masks: np.ndarray):  
        image_array = np.array(image)
        if image_array.shape[-1] == 4:  # Handle RGBA images
            image_array = image_array[:, :, :3]

        # Resize binary masks to match the image dimensions
        resized_masks = [
            np.array(Image.fromarray(mask.astype(np.uint8)).resize(image.size, Image.NEAREST), dtype=bool)
            for mask in masks
        ]

        # Generate random colors for each mask
        num_masks = len(resized_masks)
        colors = [tuple(randint(0, 255) for _ in range(3)) for _ in range(num_masks)]

        # Overlay masks on the image
        overlaid_image = image_array.copy()
        for mask, color in zip(resized_masks, colors):
            overlaid_image[mask] = np.array(color, dtype=np.uint8) * 0.5 + overlaid_image[mask] * 0.5

        return overlaid_image

    def get_diameter(self, masks):
        diameters = []
        for mask in masks:
            area = np.sum(mask) 
            if area > 0:  
                diameter = np.sqrt(4 * area / np.pi)
                diameters.append(diameter)

        diameters = np.array(diameters)
        diameters_sorted = np.sort(diameters)
        return diameters_sorted 
    
    @staticmethod
    def draw_cdf_chart(diameters: np.ndarray):  
        D10 = np.percentile(diameters, 10)
        D50 = np.percentile(diameters, 50)
        D90 = np.percentile(diameters, 90)
        Dmin = diameters.min()
        Dmax = diameters.max()
        Davg = diameters.mean()

        cdf = np.arange(1, len(diameters) + 1) / len(diameters) * 100
        plt.figure(figsize=(12, 8))
        plt.plot(diameters, cdf, marker='.', linestyle='-', label='CDF', color='blue')

        # Add vertical lines for D10, D50, D90
        plt.axvline(D10, color='deepskyblue', linestyle='--', label=f'D10 = {D10:.2f}')
        plt.axvline(D50, color='purple', linestyle='--', label=f'D50 = {D50:.2f}')
        plt.axvline(D90, color='blue', linestyle='--', label=f'D90 = {D90:.2f}')
        plt.axvline(Dmin, color='green', linestyle='--', label=f'Dmin = {Dmin:.2f}')
        plt.axvline(Dmax, color='red', linestyle='--', label=f'Dmax = {Dmax:.2f}')
        plt.axvline(Davg, color='orange', linestyle='--', label=f'Davg = {Davg:.2f}')

        # Add horizontal lines for 10%, 50%, 90%
        plt.axhline(10, color='deepskyblue', linestyle='--', alpha=0.3)
        plt.axhline(50, color='purple', linestyle='--', alpha=0.3)
        plt.axhline(90, color='blue', linestyle='--', alpha=0.3)

        max_x = diameters.max()  
        plt.text(max_x * 1.01, 10, '10%', color='deepskyblue', verticalalignment='bottom', fontsize=10)
        plt.text(max_x * 1.01, 50, '50%', color='purple', verticalalignment='bottom', fontsize=10)
        plt.text(max_x * 1.01, 90, '90%', color='blue', verticalalignment='bottom', fontsize=10)

        # Customize the plot
        plt.xlabel('Fragment Size (D)')
        plt.ylabel('Cumulative Percentage (%)')
        plt.title(f'Cumulative Distribution Function (CDF) of Fragment Sizes\nTotal Fragments: {len(diameters)}')
        plt.grid(True)
        plt.legend()

        buf = BytesIO()
        plt.savefig(buf, format='png')
        buf.seek(0)
        plt.close()
        return Image.open(buf)

    async def predict(self, img: Image, conf: float=0.5, iou: float=0.5, save: bool=False):
        print("Model trying to inference...")
        try:
            results = self.model.predict(source=img, conf=conf, iou=iou, save=save)
            if results[0].masks is None:
                print("No masks were generated by the model.")
                return None
            masks = results[0].masks.data.cpu().numpy()
        except Exception as e:
            print(f"Error during prediction: {e}")
            return None

        diameters = self.get_diameter(masks)
        cdf_chart = self.draw_cdf_chart(diameters)
        overlaid_img = self.get_overlaid_mask(img, masks)
        is_calibrated = False
        print("Model inference successfully")
        return (masks, overlaid_img, diameters, cdf_chart, is_calibrated)

